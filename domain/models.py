from typing import List, Sequence, Set, Tuple
from pydantic import BaseModel, Field
from agent_framework import ContextProvider
from agent_framework import ContextProvider, Context, ChatMessage
from collections.abc import MutableSequence
from typing import Any

class TextChunk(BaseModel):
    text: str = Field(..., alias="chunk", description="The chunked text content.")
    line_span: Tuple[int, int] = Field(
        ...,
        description="Inclusive 1-based (start_line, end_line) in the source file.",
        examples=[(12, 24)],
    )
    source_file: str = Field(
        ...,
        description="Path to the file from which the chunk was extracted.",
    )
    def compare(self, other: "TextChunk") -> bool:
        """Compare two SecretsDetectorAgentMemory objects by source_file and line_span."""
        return (
            self.source_file == other.source_file
            and self.line_span == other.line_span
        )

class LineComment(BaseModel):
    line_number: int = Field(..., description="Line number in the file (1-based).")
    comment: str = Field(..., description="Reviewer comment for this line.")

class SecretsDetectorExecutorResponse(BaseModel):
    comments: List[LineComment] = Field(
        default_factory=list,
        description="All line-level comments generated by the detector.",
    )
    original_file: str = Field(
        ...,
        alias="original_file",
        description="Path to the original file that was scanned.",
    )
    executor_agent: str = Field(
        default="No agent",
        description="The id of the executor agent who processed this request",
    )
    def is_empty(self) -> bool:
        return (not self.comments) and (self.original_file == "") and (self.executor_agent == "")

class EmptySecretsDetectorExecutorResponseFactory(SecretsDetectorExecutorResponse):
    @staticmethod
    def get_empty_secrets_detector():
        return SecretsDetectorExecutorResponse(comments=[], original_file="", executor_agent="")

